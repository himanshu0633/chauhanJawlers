export function JewelleryGrid() {
  const [allProducts, setAllProducts] = useState([]);
  const [categories, setCategories] = useState([]);
  const [subcategoryName, setSubCategoryName] = useState([]);
  const [occasion, setOccasion] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [shownCount, setShownCount] = useState(12);
  const location = useLocation();

  const [filters, setFilters] = useState({
    query: "",
    priceRange: "all",
  });
  const [sortOption, setSortOption] = useState("relevance");

  // Use query parameters from URL
  function useQuery() {
    return new URLSearchParams(location.search);
  }

  const query = useQuery();
  const categoryParam = query.get("category"); // Main filter parameter based on category name
  const selectedSubcategoryId = query.get("subcategory");
  const selectedOccasionId = query.get("occasion");
  const priceQuery = query.get("price") || "all";
  const genderQuery = query.get("gender") || "all";
  const occasionQuery = query.get("occasion") || "all";

  // Helper functions
  const norm = (s) =>
    (s || "").toUpperCase().replace(/\s+/g, "").replace(/-/g, "–").trim();

  const loadMoreProducts = () => {
    setShownCount((prev) => prev + 12);
  };

  const parseQuantityArray = (q) => {
    if (!q) return [];
    let arr = q;
    if (typeof q === "string") {
      try {
        arr = JSON.parse(q);
      } catch {
        return [];
      }
    }
    return Array.isArray(arr) ? arr : [];
  };

  const pickBestVariation = (arr) => {
    if (!arr.length) return null;
    return arr.reduce(
      (best, cur) =>
        parseFloat(cur.finalPrice || 0) < parseFloat(best.finalPrice || 0)
          ? cur
          : best,
      arr[0]
    );
  };

  const preprocessProducts = (productsRaw) =>
    productsRaw.map((p) => {
      const quantityArr = parseQuantityArray(p.quantity?.[0]);
      const bestVariation = pickBestVariation(quantityArr);
      return {
        ...p,
        price: bestVariation ? parseFloat(bestVariation.finalPrice || 0) : 0,
        gst: bestVariation ? parseFloat(bestVariation.gst || 0) : null,
        discount: bestVariation ? parseFloat(bestVariation.discount || 0) : 0,
        weight: bestVariation ? parseFloat(bestVariation.weight || 0) : null,
        makingPrice: bestVariation
          ? parseFloat(bestVariation.makingPrice || 0)
          : null,
        quantityVariants: quantityArr,
        bestVariant: bestVariation,
      };
    });

  // Price buckets for filtering
  const priceBuckets = [
    { label: "Under ₹25K", min: 0, max: 25000 },
    { label: "₹25K – ₹50K", min: 25000, max: 50000 },
    { label: "₹50K – ₹1L", min: 50000, max: 100000 },
    { label: "Over ₹1L", min: 100000, max: Number.MAX_SAFE_INTEGER },
  ];

  const priceBucketFromQuery = priceBuckets.find(
    (b) => norm(b.label) === norm(priceQuery)
  );

  // Fetch functions
  const fetchAllProducts = async () => {
    setLoading(true);
    try {
      const response = await axiosInstance.get("/user/allproducts");
      const processedProducts = preprocessProducts(response.data || []);
      setAllProducts(processedProducts);
    } catch (error) {
      setError("Could not load products. Please try again.");
      console.error("Error fetching products:", error);
    } finally {
      setLoading(false);
    }
  };

  const fetchCategories = async () => {
    try {
      const response = await axiosInstance.get("/user/allcategories");
      setCategories(response.data || []);
    } catch (error) {
      console.error("Error fetching categories:", error);
    }
  };

  const fetchSubCategories = async () => {
    try {
      const response = await axiosInstance.get("/user/allSubcategories");
      setSubCategoryName(response?.data || []);
    } catch (error) {
      console.error("Error fetching subcategories:", error);
    }
  };

  const fetchOccasions = async () => {
    try {
      const response = await axiosInstance.get("/user/allOccasions");
      setOccasion(response?.data || []);
    } catch (error) {
      console.error("Error fetching occasion:", error);
    }
  };

  // Find selected items from IDs
  const selectedSubcategory = selectedSubcategoryId
    ? subcategoryName.find((item) => item._id === selectedSubcategoryId)
    : null;
  const selectedOccasion = selectedOccasionId
    ? occasion.find((item) => item._id === selectedOccasionId)
    : null;

  // Enhanced filtering logic based on category names
  const filteredProducts = allProducts.filter((product) => {
    try {
      // Search query filter
      const matchesQuery =
        !filters.query ||
        (product.name &&
          product.name.toLowerCase().includes(filters.query.toLowerCase()));

      // Price range filter
      const matchesPriceRange =
        filters.priceRange === "all" ||
        (product.price >=
          priceBuckets.find((b) => b.label === filters.priceRange)?.min &&
          product.price <=
            priceBuckets.find((b) => b.label === filters.priceRange)?.max);

      // Category filter based on category name (not variety)
      let matchesCategory = true;

      if (categoryParam && categoryParam.trim()) {
        const normalizedCategoryParam = categoryParam.toLowerCase().trim();

        // Match by category name or product variety
        const matchesByName =
          product.category &&
          product.category.toLowerCase().trim() === normalizedCategoryParam;

        const matchesByVariety =
          product.productvariety &&
          product.productvariety.toLowerCase().trim() ===
            normalizedCategoryParam;

        matchesCategory = matchesByName || matchesByVariety;
      }
      // If no category param, show all products (for "All Jewellery")

      // Subcategory filter
      const matchesSubcategory =
        !selectedSubcategory ||
        product.sub_category === selectedSubcategory.name;

      // Occasion filter
      const matchesOccasion =
        !selectedOccasion || product.occasion === selectedOccasion.name;

      // Price query filter
      const matchesPriceQuery =
        priceQuery === "all" ||
        (priceBucketFromQuery &&
          product.price >= priceBucketFromQuery.min &&
          product.price <= priceBucketFromQuery.max);

      // Gender filter
      const matchesGender =
        genderQuery === "all" ||
        (product.genderVariety &&
          product.genderVariety.toLowerCase() === genderQuery.toLowerCase());

      // Occasion query filter
      const matchesOccasionQuery =
        occasionQuery === "all" ||
        (product.occasion &&
          product.occasion.toLowerCase() === occasionQuery.toLowerCase());

      return (
        matchesQuery &&
        matchesPriceRange &&
        matchesCategory &&
        matchesSubcategory &&
        matchesOccasion &&
        matchesPriceQuery &&
        matchesGender &&
        matchesOccasionQuery
      );
    } catch (error) {
      console.error("Error in filtering:", error);
      return true; // Include product if filtering fails
    }
  });

  // Sorting logic
  const sortedProducts = filteredProducts.sort((a, b) => {
    try {
      switch (sortOption) {
        case "price-asc":
          return (a.price || 0) - (b.price || 0);
        case "price-desc":
          return (b.price || 0) - (a.price || 0);
        case "newest":
          const dateA = new Date(a.createdAt || 0);
          const dateB = new Date(b.createdAt || 0);
          return dateB - dateA;
        default:
          return 0;
      }
    } catch (error) {
      console.error("Error in sorting:", error);
      return 0;
    }
  });

  // Load data on component mount
  useEffect(() => {
    fetchAllProducts();
    fetchCategories();
    fetchSubCategories();
    fetchOccasions();
  }, []);

  // Reset shown count when filters change
  useEffect(() => {
    setShownCount(12);
  }, [
    categoryParam,
    selectedSubcategoryId,
    selectedOccasionId,
    filters,
    sortOption,
  ]);

  const productsToDisplay = sortedProducts.slice(0, shownCount);

  // Get current category name for display
  const getCurrentCategoryName = () => {
    if (!categoryParam) return "All Jewellery";

    // Find category by name or variety
    const category = categories.find(
      (cat) =>
        (cat.name && cat.name.toLowerCase() === categoryParam.toLowerCase()) ||
        (cat.variety &&
          cat.variety.toLowerCase() === categoryParam.toLowerCase()) ||
        (cat.assignedRoute &&
          cat.assignedRoute.toLowerCase() === categoryParam.toLowerCase())
    );

    if (category) return category.name;

    // Fallback to formatted category param
    return categoryParam.charAt(0).toUpperCase() + categoryParam.slice(1);
  };

  return (
    <Box>
      <Box sx={{ pt: 5, pb: 3 }}>
        {/* Category Title */}
        <Typography
          variant="h4"
          align="center"
          sx={{
            fontWeight: 700,
            mb: 4,
            fontFamily: "serif",
            color: Theme.palette.primary,
            fontSize: { xs: "28px", sm: "36px", md: "48px" },
          }}
        >
          {getCurrentCategoryName()}
        </Typography>

        {/* Filters and Sort Controls */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            flexWrap: "wrap",
            mb: 3,
            gap: 1,
          }}
        >
          <TextField
            label="Search"
            value={filters.query}
            onChange={(e) => setFilters({ ...filters, query: e.target.value })}
            sx={{ width: { xs: "48%", sm: "30%" } }}
          />
          <Select
            value={filters.priceRange}
            onChange={(e) =>
              setFilters({ ...filters, priceRange: e.target.value })
            }
            sx={{ width: { xs: "48%", sm: "30%" } }}
          >
            <MenuItem value="all">All Prices</MenuItem>
            {priceBuckets.map((bucket) => (
              <MenuItem key={bucket.label} value={bucket.label}>
                {bucket.label}
              </MenuItem>
            ))}
          </Select>

          <Select
            value={sortOption}
            onChange={(e) => setSortOption(e.target.value)}
            sx={{ width: { xs: "48%", sm: "30%" } }}
          >
            <MenuItem value="relevance">Sort by: Relevance</MenuItem>
            <MenuItem value="price-asc">Price: Low to High</MenuItem>
            <MenuItem value="price-desc">Price: High to Low</MenuItem>
            <MenuItem value="newest">Newest First</MenuItem>
          </Select>
        </Box>
      </Box>

      {/* Product Grid */}
      {loading ? (
        <Typography align="center" sx={{ py: 4 }}>
          Loading products...
        </Typography>
      ) : error ? (
        <Typography align="center" color="error" sx={{ py: 4 }}>
          {error}
        </Typography>
      ) : sortedProducts.length === 0 ? (
        <Box sx={{ textAlign: "center", py: 8 }}>
          <Typography variant="h5" color="text.secondary" gutterBottom>
            No products found
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {categoryParam
              ? `No products available in ${getCurrentCategoryName()} category. Try browsing other categories.`
              : "Try adjusting your filters or search terms"}
          </Typography>
        </Box>
      ) : (
        <>
          {/* FIXED RESPONSIVE GRID */}
          <Box
            sx={{
              display: "grid",
              gridTemplateColumns: {
                xs: "repeat(2, 1fr)",
                sm: "repeat(3, 1fr)",
                md: "repeat(4, 1fr)",
                lg: "repeat(6, 1fr)",
              },
              gap: 2,
            }}
          >
            {productsToDisplay.map((product) => (
              <Box key={product._id}>
                <JewelleryCard product={product} />
              </Box>
            ))}
          </Box>

          {/* LOAD MORE button */}
          {shownCount < sortedProducts.length && (
            <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
              <Button
                variant="outlined"
                onClick={loadMoreProducts}
                sx={{ px: 4, py: 1.5 }}
              >
                View More ({sortedProducts.length - shownCount} remaining)
              </Button>
            </Box>
          )}
        </>
      )}

      {/* Add CSS for Cart Popup */}
      <style jsx>{`
        .cart-popup-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          animation: fadeIn 0.3s ease;
        }

        .cart-popup {
          background: white;
          border-radius: 12px;
          width: 90%;
          max-width: 450px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          animation: slideUp 0.3s ease;
        }

        .popup-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 1.5rem 1.5rem 1rem;
          border-bottom: 1px solid #f0f0f0;
        }

        .popup-header h3 {
          margin: 0;
          color: #2c2c2c;
          font-size: 18px;
          font-weight: 600;
        }

        .close-button {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          color: #666;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
        }

        .close-button:hover {
          background: #f5f5f5;
        }

        .popup-content {
          padding: 1.5rem;
        }

        .popup-product {
          display: flex;
          gap: 1rem;
          align-items: center;
        }

        .popup-image {
          width: 80px;
          height: 80px;
          object-fit: cover;
          border-radius: 8px;
          border: 1px solid #f0f0f0;
        }

        .popup-details {
          flex: 1;
        }

        .popup-title {
          margin: 0 0 0.5rem 0;
          font-size: 16px;
          font-weight: 600;
          color: #2c2c2c;
          line-height: 1.3;
        }

        .popup-price {
          margin: 0 0 0.25rem 0;
          font-size: 16px;
          font-weight: 700;
          color: #44170d;
        }

        .popup-quantity {
          margin: 0;
          font-size: 14px;
          color: #666;
        }

        .popup-actions {
          padding: 1rem 1.5rem 1.5rem;
          display: flex;
          gap: 1rem;
        }

        .view-cart-btn {
          flex: 1;
          padding: 12px 16px;
          background: white;
          color: #44170d;
          border: 2px solid #44170d;
          border-radius: 6px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .view-cart-btn:hover {
          background: #44170d;
          color: white;
        }

        @keyframes fadeIn {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @media (max-width: 480px) {
          .cart-popup {
            width: 95%;
            margin: 1rem;
          }

          .popup-actions {
            flex-direction: column;
          }

          .popup-product {
            flex-direction: column;
            text-align: center;
          }
        }
      `}</style>
    </Box>
  );
}